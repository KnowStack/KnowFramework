# 							Web工程编码规范 V0.1

## 命名风格

- 代码中的命名严禁使用拼音与英文混合方式，更不允许直接使用中文的方式
- 类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID
- 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长
- 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾
- 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。**包名统一使用单数形式**，但是**类名如果有复数含义，类名可以使用复数形式**
- 杜绝完全不规范的缩写，避免望文不知义，为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意
- 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式
- 接口类中的方法和属性不要加任何修饰符号(public 也不要加)，保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量
- 接口和实现类的命名有两套规则
- 对于Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别
- 如果是形容能力的接口名称，取对应的形容词为接口名(**通常是–able 的形式**)。 正例:AbstractTranslator 实现 Translatable 接口
- 枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔
- 各层命名规约
  - Service/DAO层方法命名规约
    -  获取单个对象的方法用get做前缀
    -  获取多个对象的方法用list做前缀，复数形式结尾如:listObjects
    -  获取统计值的方法用count做前缀
    -  插入的方法用save/insert做前缀
    - 删除的方法用remove/delete做前缀
    - 修改的方法用update做前缀
  - 领域模型命名规约
    - 数据对象:xxxDO，xxx即为数据表名
    - 数据传输对象:xxxDTO，xxx为业务领域相关的名称
    - 展示对象:xxxVO，xxx一般为网页名称
    - POJO是DO/DTO/BO/VO的统称
  - 配置文件、动态配置命名规范
    - 必须使用小写字母，禁止出现数字开头，组合名词之间用下划线链接
    - 不同实体之间用逗号链接，配置样例：arius.stats.cluster_info

## 常量定义

- 不允许任何魔法值(即未经预先定义的常量)直接出现在代码中 
- 在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解 
- 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护
- 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量 
  - 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下 
  -  应用内共享常量：放置在一方库中，通常是子模块中的constant目录下 
  - 子工程内部共享常量：即在当前子工程的constant目录下 
  - 包内共享常量：即在当前包下单独的constant目录下 
  - 类内共享常量:直接在类内部private static final定义 
  - 如果变量值仅在一个固定范围内变化用 enum 类型来定义

## OOP 规约

- 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成，本直接用类名来访问即可
- **不能使用过时的类或方法** 
- 关于基本数据类型与包装数据类型的使用标准如下
  - 所有的POJO类属性必须使用包装数据类型
  - RPC方法的返回值和参数必须使用包装数据类型 
  - 所有的局部变量使用基本数据类型
- 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值 
- 序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败 
- **构造方法里面禁止加入任何业务逻辑**，如果有初始化逻辑，请放在 init 方法中 
- 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起， 便于阅读 
- 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法 
- 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展 
-  final 可以声明类、成员变量、方法、以及本地变量 
  - 不允许被继承的类，如:String 类 
  - 不允许修改引用的域对象
  - 不允许被重写的方法，如:POJO 类的 setter 方法 
  - 不允许运行过程中重新赋值的局部变量
  - 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好 地进行重构 
- 类成员与方法访问控制从严，过于宽泛的访问范围，不利于模块解耦 
  - 如果不允许外部直接通过new来创建对象，那么构造方法必须是private 
  - 工具类不允许有public或default构造方法 
  - 类非static成员变量并且与子类共享，必须是protected
  - 类非static成员变量并且仅在本类使用，必须是private
  - 类static成员变量如果仅在本类使用，必须是private
  - 若是static成员变量，考虑是否为final
  - 类成员方法只供类内部调用，必须是private
  - 类成员方法只对继承类公开，那么限制为protected

## 集合处理

- 在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、 增加、删除产生ConcurrentModificationException 异常 
- 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size() 
- 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常
- 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁 
- 集合初始化时，指定集合初始值大小
- 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 

## 并发处理

- **创建线程或线程池时请指定有意义的线程名称，方便出错时回溯** 
- 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程
- 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处**理方式让写的同学更加明确线程池的运行规则**，规避资源耗尽的风险 
- 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体;能用对象锁，就不要用类锁 
- 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁 
- 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据 
- 使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行 至 await 方法，直到超时才返回结果
- HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中可以使用其它数据结构或加锁来规避此风险

## 控制语句

- 在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使空代码 
- 在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，避免采用 单行的编码方式 
- 在高并发场景中，避免使用”等于”判断作为中断或退出的条件，容易产生等值判断被“击穿”的情况，使用大于或小于的区间 判断条件来代替 
- 表达异常的分支时，少用 if-else 方式，这种方式可以改写成:if (condition) { ... return obj; }
- 除常用方法(如 getXxx/isXxx)等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性 
- 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外) 

## 异常处理

- Java类库中定义的可以通过预检查方式规避的RuntimeException 异常不应该通过 catch 的方式来处理，比如:NullPointerException，IndexOutOfBoundsException 
- 异常不要用来做流程控制，条件控制
- 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者 
- 有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务 
- finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch 
- 不要在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句 
- **捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类**
- 方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 说明什么情况下会返回 null 值 
- **防止 NPE，是程序员的基本修养，注意 NPE 产生的场景**
- 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE 
- 数据库的查询结果可能为null 
- 集合里的元素即使isNotEmpty，**取出的数据元素也可能为nul**l 
- 远程调用返回对象时，一律要求进行空指针判断，防止NPE 
- 级联调用obj.getA().getB().getC();一连串调用，易产生NPE 
- **定义时区分unchecked/checked 异常，避免直接抛出newRuntimeException()， 更不允许抛出 Exception 或者 Throwable**
- **对于公司外的 http/api 开放接口必须使用“错误码”;而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简 短信息**

## 注释规约

- 类、类属性、**类方法的注释必须使用 Javadoc 规范，使用/\**内容\*/格式，不得使用 // xxx方式**
- 所有的抽象方法(包括接口中的方法)**必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能**
- 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/* */注释，注意与代码对齐 
- 所有的枚举类型字段必须要有注释，说明每个数据项的用途
- **与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可**
- 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改 
-  对于注释的要求：能够准确反应设计思想和代码逻辑；能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息
- 特殊注释标记，请注明标记人与标记时间： 待办事宜(TODO):( 标记人，标记时间，[预计处理时间])，请及时处理

## 日志规约

- **应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log**
- **对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式**
-  避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false 
- **异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出**
- 谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info 日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志 
- 可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。如非必要，请不要在此场景打出 error 级别，避免频繁报警 

## 测试规范

- 单元测试

  - 对于单元测试，**要保证测试粒度足够小，有助于精确定位问题，**一般是方法级别
    - 信息能否正确地流入和流出单元 ，满足特定的逻辑覆盖 
    -  出错处理措施是否有效

  - **核心业务、核心应用**、核心模块的增量代码确保单元测试通过

  - 对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的， 或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据 

  - 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据

- 集成测试

  - Controller层接口集成测试 ，只关注流程正常工作，响应体关键字段校验
  - 对外发布的API，需要校验字段的完整性，功能的完备性
  - 验证软件系统是否满足了PRD文档功能与体验，测试环境发布，需要走完整前后端联动验证流程

## 最佳实践

- 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度
- 不要在视图模板中加入任何复杂的逻辑
- 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存
- **及时清理不再使用的代码段或配置信息，对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余**
-  [Sonar插件安装](https://plugins.jetbrains.com/plugin/7973-sonarlint)，进行代码规范检视